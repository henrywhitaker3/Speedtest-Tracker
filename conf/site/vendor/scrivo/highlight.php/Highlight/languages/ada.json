{
    "case_insensitive": true,
    "keywords": {
        "keyword": "abort else new return abs elsif not reverse abstract end accept entry select access exception of separate aliased exit or some all others subtype and for out synchronized array function overriding at tagged generic package task begin goto pragma terminate body private then if procedure type case in protected constant interface is raise use declare range delay limited record when delta loop rem while digits renames with do mod requeue xor",
        "literal": "True False"
    },
    "contains": [
        {
            "className": "comment",
            "begin": "--",
            "end": "$",
            "contains": [
                {
                    "begin": "\\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\\b"
                },
                {
                    "className": "doctag",
                    "begin": "(?:TODO|FIXME|NOTE|BUG|XXX):",
                    "relevance": 0
                }
            ]
        },
        {
            "className": "string",
            "begin": "\"",
            "end": "\"",
            "contains": [
                {
                    "begin": "\"\"",
                    "relevance": 0
                }
            ]
        },
        {
            "className": "string",
            "begin": "'.'"
        },
        {
            "className": "number",
            "begin": "\\b(\\d(_|\\d)*#\\w+(\\.\\w+)?#([eE][-+]?\\d(_|\\d)*)?|\\d(_|\\d)*(\\.\\d(_|\\d)*)?([eE][-+]?\\d(_|\\d)*)?)",
            "relevance": 0
        },
        {
            "className": "symbol",
            "begin": "'[A-Za-z](_?[A-Za-z0-9.])*"
        },
        {
            "className": "title",
            "begin": "(\\bwith\\s+)?(\\bprivate\\s+)?\\bpackage\\s+(\\bbody\\s+)?",
            "end": "(is|$)",
            "keywords": "package body",
            "excludeBegin": true,
            "excludeEnd": true,
            "illegal": "\\Q[]{}%#'\"\\E"
        },
        {
            "begin": "(\\b(with|overriding)\\s+)?\\b(function|procedure)\\s+",
            "end": "(\\bis|\\bwith|\\brenames|\\)\\s*;)",
            "keywords": "overriding function procedure with is renames return",
            "returnBegin": true,
            "contains": [
                {
                    "$ref": "#contains.0"
                },
                {
                    "className": "title",
                    "begin": "(\\bwith\\s+)?\\b(function|procedure)\\s+",
                    "end": "(\\(|\\s+|$)",
                    "excludeBegin": true,
                    "excludeEnd": true,
                    "illegal": "\\Q[]{}%#'\"\\E"
                },
                {
                    "begin": "\\s+:\\s+",
                    "end": "\\s*(:=|;|\\)|=>|$)",
                    "illegal": "\\Q[]{}%#'\"\\E",
                    "contains": [
                        {
                            "beginKeywords": "loop for declare others",
                            "endsParent": true
                        },
                        {
                            "className": "keyword",
                            "beginKeywords": "not null constant access function procedure in out aliased exception"
                        },
                        {
                            "className": "type",
                            "begin": "[A-Za-z](_?[A-Za-z0-9.])*",
                            "endsParent": true,
                            "relevance": 0
                        }
                    ]
                },
                {
                    "className": "type",
                    "begin": "\\breturn\\s+",
                    "end": "(\\s+|;|$)",
                    "keywords": "return",
                    "excludeBegin": true,
                    "excludeEnd": true,
                    "endsParent": true,
                    "illegal": "\\Q[]{}%#'\"\\E"
                }
            ]
        },
        {
            "className": "type",
            "begin": "\\b(sub)?type\\s+",
            "end": "\\s+",
            "keywords": "type",
            "excludeBegin": true,
            "illegal": "\\Q[]{}%#'\"\\E"
        },
        {
            "$ref": "#contains.6.contains.2"
        }
    ]
}
