{
    "keywords": {
        "keyword": "#available #colorLiteral #column #else #elseif #endif #file #fileLiteral #function #if #imageLiteral #line #selector #sourceLocation _ __COLUMN__ __FILE__ __FUNCTION__ __LINE__ Any as as! as? associatedtype associativity break case catch class continue convenience default defer deinit didSet do dynamic dynamicType else enum extension fallthrough false fileprivate final for func get guard if import in indirect infix init inout internal is lazy left let mutating nil none nonmutating open operator optional override postfix precedence prefix private protocol Protocol public repeat required rethrows return right self Self set static struct subscript super switch throw throws true try try! try? Type typealias unowned var weak where while willSet",
        "literal": "true false nil",
        "built_in": "abs advance alignof alignofValue anyGenerator assert assertionFailure bridgeFromObjectiveC bridgeFromObjectiveCUnconditional bridgeToObjectiveC bridgeToObjectiveCUnconditional c contains count countElements countLeadingZeros debugPrint debugPrintln distance dropFirst dropLast dump encodeBitsAsWords enumerate equal fatalError filter find getBridgedObjectiveCType getVaList indices insertionSort isBridgedToObjectiveC isBridgedVerbatimToObjectiveC isUniquelyReferenced isUniquelyReferencedNonObjC join lazy lexicographicalCompare map max maxElement min minElement numericCast overlaps partition posix precondition preconditionFailure print println quickSort readLine reduce reflect reinterpretCast reverse roundUpToAlignment sizeof sizeofValue sort split startsWith stride strideof strideofValue swap toString transcode underestimateCount unsafeAddressOf unsafeBitCast unsafeDowncast unsafeUnwrap unsafeReflect withExtendedLifetime withObjectAtPlusZero withUnsafePointer withUnsafePointerToObject withUnsafeMutablePointer withUnsafeMutablePointers withUnsafePointer withUnsafePointers withVaList zip"
    },
    "contains": [
        {
            "className": "string",
            "contains": [
                {
                    "begin": "\\\\[\\s\\S]",
                    "relevance": 0
                },
                {
                    "className": "subst",
                    "begin": "\\\\\\(",
                    "end": "\\)",
                    "keywords": {
                        "$ref": "#keywords"
                    },
                    "contains": [
                        {
                            "className": "number",
                            "begin": "\\b([\\d_]+(\\.[\\deE_]+)?|0x[a-fA-F0-9_]+(\\.[a-fA-F0-9p_]+)?|0b[01_]+|0o[0-7_]+)\\b",
                            "relevance": 0
                        }
                    ]
                }
            ],
            "variants": [
                {
                    "begin": "\"\"\"",
                    "end": "\"\"\""
                },
                {
                    "begin": "\"",
                    "end": "\""
                }
            ]
        },
        {
            "className": "comment",
            "begin": "\/\/",
            "end": "$",
            "contains": [
                {
                    "begin": "\\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\\b"
                },
                {
                    "className": "doctag",
                    "begin": "(?:TODO|FIXME|NOTE|BUG|XXX):",
                    "relevance": 0
                }
            ]
        },
        {
            "className": "comment",
            "begin": "\/\\*",
            "end": "\\*\/",
            "contains": [
                "self",
                {
                    "$ref": "#contains.1.contains.0"
                },
                {
                    "className": "doctag",
                    "begin": "(?:TODO|FIXME|NOTE|BUG|XXX):",
                    "relevance": 0
                }
            ]
        },
        {
            "className": "type",
            "begin": "\\b[A-Z][\\wÀ\\-ʸ']*[!?]"
        },
        {
            "className": "type",
            "begin": "\\b[A-Z][\\wÀ\\-ʸ']*",
            "relevance": 0
        },
        {
            "$ref": "#contains.0.contains.1.contains.0"
        },
        {
            "className": "function",
            "beginKeywords": "func",
            "end": "{",
            "excludeEnd": true,
            "contains": [
                {
                    "className": "title",
                    "begin": "[A-Za-z$_][0-9A-Za-z$_]*",
                    "relevance": 0
                },
                {
                    "begin": "<",
                    "end": ">"
                },
                {
                    "className": "params",
                    "begin": "\\(",
                    "end": "\\)",
                    "endsParent": true,
                    "keywords": {
                        "$ref": "#keywords"
                    },
                    "contains": [
                        "self",
                        {
                            "$ref": "#contains.0.contains.1.contains.0"
                        },
                        {
                            "$ref": "#contains.0"
                        },
                        {
                            "className": "comment",
                            "begin": "\/\\*",
                            "end": "\\*\/",
                            "contains": [
                                {
                                    "$ref": "#contains.1.contains.0"
                                },
                                {
                                    "className": "doctag",
                                    "begin": "(?:TODO|FIXME|NOTE|BUG|XXX):",
                                    "relevance": 0
                                }
                            ]
                        },
                        {
                            "begin": ":"
                        }
                    ],
                    "illegal": "[\"']"
                }
            ],
            "illegal": "\\[|%"
        },
        {
            "className": "class",
            "beginKeywords": "struct protocol class extension enum",
            "keywords": {
                "$ref": "#keywords"
            },
            "end": "\\{",
            "excludeEnd": true,
            "contains": [
                {
                    "className": "title",
                    "begin": "[A-Za-z$_][\\x{00C0}-\\x{02B8}0-9A-Za-z$_]*",
                    "relevance": 0
                }
            ]
        },
        {
            "className": "meta",
            "begin": "(@discardableResult|@warn_unused_result|@exported|@lazy|@noescape|@NSCopying|@NSManaged|@objc|@objcMembers|@convention|@required|@noreturn|@IBAction|@IBDesignable|@IBInspectable|@IBOutlet|@infix|@prefix|@postfix|@autoclosure|@testable|@available|@nonobjc|@NSApplicationMain|@UIApplicationMain|@dynamicMemberLookup|@propertyWrapper)"
        },
        {
            "beginKeywords": "import",
            "end": "$",
            "contains": [
                {
                    "$ref": "#contains.1"
                },
                {
                    "$ref": "#contains.2"
                }
            ]
        }
    ]
}
